<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Auto Battler - Pro Edition</title>
    <style>
        :root {
            --bg-color: #000000;
            --glass-surface: rgba(30, 30, 40, 0.65);
            --glass-border: rgba(255, 255, 255, 0.12);
            --glass-highlight: rgba(255, 255, 255, 0.05);
            --accent-color: #0a84ff;
            --accent-gradient: linear-gradient(135deg, #0a84ff, #5e5ce6);
            --text-primary: #f5f5f7;
            --text-secondary: #86868b;
            --cost-1: #a0a0a0;
            --cost-2: #30d158;
            --cost-3: #0a84ff;
            --font-stack: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            font-family: var(--font-stack);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #bg-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1;
            background-image: url('assets/background.png');
            background-size: cover;
            background-position: center;
            filter: brightness(0.4) blur(8px) saturate(1.2);
            transform: scale(1.05); 
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .pointer-events-auto { pointer-events: auto; }

        .glass-panel {
            background: var(--glass-surface);
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        #top-bar {
            height: 64px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            margin-bottom: 20px;
        }

        .stat-group { display: flex; gap: 24px; font-weight: 600; font-size: 15px; letter-spacing: -0.3px; }
        .stat-item { display: flex; align-items: center; gap: 8px; }
        .stat-icon { font-size: 18px; filter: drop-shadow(0 0 5px rgba(255,255,255,0.3)); }

        .control-group { display: flex; gap: 12px; }
        
        .icon-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px; height: 40px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 18px;
        }
        .icon-btn:hover { background: rgba(255, 255, 255, 0.25); transform: scale(1.05); }

        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto; 
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); 
            image-rendering: -webkit-optimize-contrast;
        }

        #synergy-float {
            position: absolute;
            left: 20px;
            top: 100px;
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none; 
            z-index: 20;
        }
        .syn-tag {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 10px 14px;
            border-radius: 12px;
            border-left: 4px solid #555;
            color: #fff;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }
        .syn-tag.active {
            border-left-color: var(--cost-2);
            background: rgba(20, 40, 30, 0.85);
            transform: translateX(5px);
        }
        .syn-head { display: flex; justify-content: space-between; font-size: 13px; font-weight: 700; margin-bottom: 4px; }
        .syn-body { font-size: 11px; color: #ccc; line-height: 1.3; }

        #shop-dock {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(150%);
            width: auto;
            min-width: 600px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            transition: transform 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 100;
        }

        #shop-dock.visible {
            transform: translateX(-50%) translateY(0);
        }

        .shop-cards {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .card {
            width: 110px;
            height: 150px;
            position: relative;
            border-radius: 14px;
            background: linear-gradient(160deg, #2a2a2e, #1c1c1e);
            border: 1px solid rgba(255,255,255,0.08);
            cursor: pointer;
            transition: all 0.3s;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .card:hover { transform: translateY(-10px) scale(1.05); z-index: 10; border-color: rgba(255,255,255,0.4); }
        .card:active { transform: scale(0.95); }

        .card[data-cost="1"] { border-bottom: 3px solid var(--cost-1); }
        .card[data-cost="2"] { border-bottom: 3px solid var(--cost-2); }
        .card[data-cost="3"] { border-bottom: 3px solid var(--cost-3); }

        .card-img-box {
            width: 80px; height: 80px;
            margin-top: 12px;
            border-radius: 12px;
            background: rgba(0,0,0,0.3);
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
        }
        .card-img-box img { width: 100%; height: 100%; object-fit: contain; }

        .card-info { padding: 8px 4px; text-align: center; width: 100%; }
        .c-name { font-size: 13px; font-weight: 700; color: #fff; margin-bottom: 4px; }
        .c-meta { font-size: 10px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .c-cost { 
            position: absolute; top: 6px; right: 6px; 
            font-size: 11px; font-weight: 800; color: #ffd700; 
            background: rgba(0,0,0,0.6); padding: 2px 6px; border-radius: 6px;
        }

        .shop-actions { display: flex; justify-content: space-between; align-items: center; padding: 0 10px; }

        .action-btn {
            padding: 12px 32px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 15px;
            border: none;
            cursor: pointer;
            transition: 0.2s;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            display: flex; align-items: center; gap: 8px;
        }

        .btn-reroll { background: rgba(255, 255, 255, 0.08); color: var(--accent-color); }
        .btn-reroll:hover { background: rgba(255, 255, 255, 0.15); }

        .btn-battle { background: var(--accent-gradient); color: white; box-shadow: 0 4px 20px rgba(10, 132, 255, 0.4); }
        .btn-battle:hover { transform: translateY(-2px); box-shadow: 0 8px 25px rgba(10, 132, 255, 0.5); }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            justify-content: center; align-items: center;
            opacity: 0; animation: fadeIn 0.3s forwards;
        }
        @keyframes fadeIn { to { opacity: 1; } }

        .modal-card {
            background: #1c1c1e;
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 40px;
            width: 90%; max-width: 380px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.6);
            transform: scale(0.9); animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes popIn { to { transform: scale(1); } }

        .modal-card h2 { margin: 0 0 10px; font-size: 24px; background: var(--accent-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .modal-card p { color: var(--text-secondary); margin-bottom: 24px; font-size: 14px; }
        
        .apple-input {
            background: #2c2c2e; border: none;
            color: white; padding: 14px; border-radius: 12px;
            width: 100%; box-sizing: border-box; margin-bottom: 20px;
            font-size: 16px; text-align: center; outline: none;
            transition: box-shadow 0.2s;
        }
        .apple-input:focus { box-shadow: 0 0 0 2px var(--accent-color); }

        .float-text {
            position: absolute;
            font-weight: 800;
            pointer-events: none;
            animation: floatUp 0.6s cubic-bezier(0.23, 1, 0.32, 1) forwards;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 500;
        }
        @keyframes floatUp {
            0% { opacity: 0; transform: translate(-50%, 0) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -20px) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -60px) scale(1); }
        }

        #loading {
            position: fixed; z-index: 9999; background: #000;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: #666; font-size: 12px; letter-spacing: 2px; text-transform: uppercase;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--accent-color); border-radius: 50%;
            animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 850px) {
            #shop-dock { min-width: 100%; width: 100%; bottom: 0; border-radius: 24px 24px 0 0; padding-bottom: 30px; }
            .shop-cards { overflow-x: auto; justify-content: flex-start; padding: 4px 10px; }
            .card { flex-shrink: 0; }
            #top-bar { padding: 0 12px; height: 50px; }
            .stat-group { gap: 12px; font-size: 13px; }
            #synergy-float { display: none; } 
        }
    </style>
</head>
<body>

    <div id="bg-layer"></div>
    <div id="loading"><div class="spinner"></div>LOADING RESOURCES</div>

    <div id="ui-layer">
        <div id="top-bar" class="glass-panel pointer-events-auto">
            <div class="stat-group">
                <div class="stat-item" style="color: #ff5f57;"><span class="stat-icon">‚ù§Ô∏è</span> <span id="ui-hp">100</span></div>
                <div class="stat-item" style="color: #febc2e;"><span class="stat-icon">üí∞</span> <span id="ui-gold">10</span></div>
                <div class="stat-item" style="color: #fff;"><span class="stat-icon">‚öîÔ∏è</span> <span id="ui-round">1</span></div>
            </div>
            <div class="control-group">
                <button class="icon-btn" onclick="game.toggleLang()">üåê</button>
                <button class="icon-btn" onclick="game.showRankings()">üèÜ</button>
            </div>
        </div>

        <div id="synergy-float"></div>

        <div id="shop-dock" class="glass-panel pointer-events-auto">
            <div class="shop-cards" id="shop-container"></div>
            <div class="shop-actions">
                <button class="action-btn btn-reroll" onclick="game.rerollShop()">
                    <span style="font-size:18px; margin-right:5px;">‚Ü∫</span> <span id="txt-reroll">Reroll</span> <span style="opacity:0.6; font-size:12px; margin-left:4px;">(2g)</span>
                </button>
                <button id="btn-battle" class="action-btn btn-battle" onclick="game.toggleState()">
                    <span style="font-size:18px;">‚öîÔ∏è</span> <span id="txt-battle">Start Battle</span>
                </button>
            </div>
        </div>
    </div>

    <div id="canvas-wrapper">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="login-modal" class="modal-overlay pointer-events-auto">
        <div class="modal-card">
            <h2 id="t-login-title">Welcome</h2>
            <p id="t-login-desc">Enter Commander Name</p>
            <input type="text" id="username-input" class="apple-input" placeholder="Nickname" maxlength="12">
            <button class="action-btn btn-battle" style="width:100%; justify-content:center;" onclick="game.login()">Start Game</button>
        </div>
    </div>

    <div id="rank-modal" class="modal-overlay pointer-events-auto" onclick="if(event.target===this) this.style.display='none'">
        <div class="modal-card" style="text-align:left;">
            <h2 id="t-rank-title">Leaderboard</h2>
            <div id="rank-list-content" style="max-height:300px; overflow-y:auto; margin:20px 0; font-size:14px;"></div>
            <button class="action-btn btn-reroll" style="width:100%; justify-content:center;" onclick="document.getElementById('rank-modal').style.display='none'">Close</button>
        </div>
    </div>

    <script>
        const LANG = {
            en: {
                reroll: "Refresh",
                battleStart: "BATTLE",
                battleFighting: "FIGHTING...",
                battleNext: "NEXT ROUND",
                victory: "VICTORY",
                defeat: "DEFEAT",
                gameOver: "GAME OVER",
                emptyBench: "Bench Full!",
                loginTitle: "Welcome Commander",
                loginDesc: "Enter your ID to sync data",
                rankTitle: "Local Rankings",
                units: {
                    'saber': { name: 'Knight' },
                    'archer': { name: 'Ranger' },
                    'mage': { name: 'Witch' },
                    'ninja': { name: 'Ninja' },
                    'tank': { name: 'Mecha' }
                },
                synergies: {
                    'Isekai': { name: "Isekai", desc: "Allies +25% ATK" },
                    'Cyber': { name: "Cyber", desc: "Allies +35% Speed" },
                    'Magic': { name: "Arcane", desc: "Skill DMG +40%" },
                    'School': { name: "Academy", desc: "Ranger Crit +15%" },
                    'Guardian': { name: "Guardian", desc: "Shield +300" },
                    'Warrior': { name: "Warrior", desc: ""},
                    'Ranger': { name: "Ranger", desc: ""},
                    'Mage': { name: "Mage", desc: ""},
                    'Assassin': { name: "Assassin", desc: ""}
                }
            },
            zh: {
                reroll: "Âà∑Êñ∞ÂïÜÂ∫ó",
                battleStart: "ÂºÄÂßãÊàòÊñó",
                battleFighting: "ÊàòÊñó‰∏≠...",
                battleNext: "‰∏ã‰∏ÄÂõûÂêà",
                victory: "ÊàòÊñóËÉúÂà©",
                defeat: "ÊàòÊñóÂ§±Ë¥•",
                gameOver: "Ê∏∏ÊàèÁªìÊùü",
                emptyBench: "Â§áÊàòÂå∫Â∑≤Êª°ÔºÅ",
                loginTitle: "Ê¨¢ËøéÊåáÊå•ÂÆò",
                loginDesc: "ÁôªËÆ∞‰Ω†ÁöÑ‰ª£Âè∑",
                rankTitle: "Êú¨Âú∞ÊéíË°åÊ¶ú",
                units: {
                    'saber': { name: 'È™ëÂ£´Âß¨' },
                    'archer': { name: 'ÂºìÈÅìÈÉ®' },
                    'mage': { name: 'È≠îÂ•≥' },
                    'ninja': { name: 'ËµõÂçöÂøç' },
                    'tank': { name: 'ÈáçË£ÖÊú∫' }
                },
                synergies: {
                    'Isekai': { name: "ÂºÇ‰∏ñÁïå", desc: "ÂÖ®ÂëòÊîªÂáª +25%" },
                    'Cyber': { name: "ËµõÂçö", desc: "ÂÖ®ÂëòÊîªÈÄü +35%" },
                    'Magic': { name: "Â••ÊúØ", desc: "ÊäÄËÉΩ‰º§ÂÆ≥ +40%" },
                    'School': { name: "Â≠¶Èô¢", desc: "Â∞ÑÊâãÊö¥Âáª +15%" },
                    'Guardian': { name: "ÂÆàÊä§ËÄÖ", desc: "Ëé∑ÂæóÊä§Áõæ +300" },
                    'Warrior': { name: "ÊàòÂ£´", desc: ""},
                    'Ranger': { name: "Â∞ÑÊâã", desc: ""},
                    'Mage': { name: "Ê≥ïÂ∏à", desc: ""},
                    'Assassin': { name: "Âà∫ÂÆ¢", desc: ""}
                }
            }
        };

        const GRID_W = 10;
        const GRID_H = 6;
        const LOGICAL_WIDTH = 1280; 
        const LOGICAL_HEIGHT = 720;
        const TILE_SIZE = LOGICAL_HEIGHT / (GRID_H + 2); 

        const ASSET_SOURCES = {
            'saber': 'assets/units/knight.png',
            'archer': 'assets/units/ranger.png',
            'mage': 'assets/units/witch.png',
            'ninja': 'assets/units/ninja.png',
            'tank': 'assets/units/mecha.png'
        };

        const UNIT_STATS = {
            'saber':  { cost: 1, hp: 700, dmg: 60, range: 1, speed: 1.1, origin: 'Isekai', class: 'Warrior' },
            'archer': { cost: 2, hp: 500, dmg: 85, range: 4, speed: 0.85, origin: 'School', class: 'Ranger' },
            'mage':   { cost: 3, hp: 400, dmg: 130, range: 3, speed: 0.65, origin: 'Magic', class: 'Mage' },
            'ninja':  { cost: 2, hp: 550, dmg: 95, range: 1, speed: 1.5, origin: 'Cyber', class: 'Assassin' },
            'tank':   { cost: 1, hp: 1000, dmg: 35, range: 1, speed: 0.7, origin: 'Cyber', class: 'Guardian' }
        };

        const SYN_RULES = {
            'Isekai': { req: 2 }, 'Cyber': { req: 2 }, 'Magic': { req: 2 },
            'School': { req: 1 }, 'Guardian': { req: 2 }
        };

        const TEXTURES = {};
        function loadAssets(cb) {
            let loaded = 0;
            const keys = Object.keys(ASSET_SOURCES);
            if(keys.length === 0) return cb();
            keys.forEach(k => {
                const img = new Image();
                img.src = ASSET_SOURCES[k];
                img.onload = () => { if(++loaded >= keys.length) cb(); };
                img.onerror = () => { if(++loaded >= keys.length) cb(); }; 
                TEXTURES[k] = img;
            });
        }

        class Unit {
            constructor(type, team, r, c) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.type = type;
                this.team = team; 
                this.r = r; this.c = c;
                
                this.pixelX = this.getGridX(c);
                this.pixelY = this.getGridY(r);
                this.targetX = this.pixelX;
                this.targetY = this.pixelY;
                
                const data = UNIT_STATS[type];
                this.maxHp = data.hp; this.hp = data.hp;
                this.dmg = data.dmg; this.range = data.range;
                this.as = data.speed;
                this.origin = data.origin; this.class = data.class;
                
                this.mana = 0; this.maxMana = 100;
                this.lastAtk = 0;
                this.isDead = false;
                this.scale = 1;
                this.animOffset = Math.random() * 100;
            }

            getGridX(c) {
                const boardWidth = GRID_W * TILE_SIZE;
                const startX = (LOGICAL_WIDTH - boardWidth) / 2;
                return startX + c * TILE_SIZE + TILE_SIZE/2;
            }

            getGridY(r) {
                const boardHeight = GRID_H * TILE_SIZE;
                const startY = (LOGICAL_HEIGHT - boardHeight) / 2;
                return startY + r * TILE_SIZE + TILE_SIZE/2;
            }

            snap() {
                const boardWidth = GRID_W * TILE_SIZE;
                const boardHeight = GRID_H * TILE_SIZE;
                const startX = (LOGICAL_WIDTH - boardWidth) / 2;
                const startY = (LOGICAL_HEIGHT - boardHeight) / 2;

                let c = Math.floor((this.pixelX - startX) / TILE_SIZE);
                let r = Math.floor((this.pixelY - startY) / TILE_SIZE);

                if (c < 0) c = 0; if (c >= GRID_W) c = GRID_W - 1;
                if (r < 0) r = 0; if (r >= GRID_H) r = GRID_H - 1;

                if (this.team === 0) {
                    if (r < 3) r = 3;
                }

                this.c = c; this.r = r;
                this.targetX = this.getGridX(c);
                this.targetY = this.getGridY(r);
            }

            // --- FIX: Only snap to grid if in PLANNING state ---
            update(dt, state) {
                if (state === 'PLANNING' && !this.isDragging) {
                    this.pixelX += (this.targetX - this.pixelX) * 10 * dt;
                    this.pixelY += (this.targetY - this.pixelY) * 10 * dt;
                }
                // Animation always runs
                if (!this.isDead) {
                    this.breathing = Math.sin((Date.now() / 500) + this.animOffset) * 0.03;
                }
            }

            draw(ctx) {
                if (this.isDead) return;
                const size = TILE_SIZE * 0.9;
                const cx = this.pixelX;
                const cy = this.pixelY + (this.breathing || 0) * 10;

                ctx.save();
                ctx.translate(cx, cy);
                
                const dir = this.team === 1 ? -1 : 1;
                const s = (this.scale + (this.breathing||0)) * (this.team === 1 ? -1 : 1);
                ctx.scale(Math.abs(s) * dir, Math.abs(s)); 

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.beginPath();
                ctx.ellipse(0, size/2 - 5, size/3, size/8, 0, 0, Math.PI*2);
                ctx.fill();

                // Image
                const img = TEXTURES[this.type];
                if (img) {
                    ctx.drawImage(img, -size/2, -size/2, size, size);
                } else {
                    ctx.fillStyle = this.team===0 ? '#4cd137' : '#e84118';
                    ctx.beginPath(); ctx.arc(0,0, size/3, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();

                // Bars
                const barW = size * 0.8;
                const barY = cy - size/2 - 10;
                
                ctx.fillStyle = '#2d3436';
                ctx.beginPath(); ctx.roundRect(cx - barW/2, barY, barW, 8, 4); ctx.fill();
                
                const hpPct = this.hp / this.maxHp;
                ctx.fillStyle = this.team === 0 ? '#30d158' : '#ff453a';
                ctx.beginPath(); ctx.roundRect(cx - barW/2, barY, barW * hpPct, 8, 4); ctx.fill();

                if (this.mana > 0) {
                    ctx.fillStyle = '#0a84ff';
                    ctx.beginPath(); ctx.roundRect(cx - barW/2, barY + 10, barW * (this.mana/this.maxMana), 4, 2); ctx.fill();
                }
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');

                const browserLang = navigator.language || navigator.userLanguage; 
                this.lang = browserLang.toLowerCase().startsWith('zh') ? 'zh' : 'en';
                
                this.handleResize();
                window.addEventListener('resize', () => this.handleResize());

                this.units = [];
                this.gold = 12;
                this.hp = 100;
                this.round = 1;
                this.state = 'PLANNING';
                this.dragging = null;
                this.bindInput();
            }

            handleResize() {
                const wrapper = document.getElementById('canvas-wrapper');
                const rect = wrapper.getBoundingClientRect();
                const aspect = LOGICAL_WIDTH / LOGICAL_HEIGHT;
                let finalW = rect.width;
                let finalH = rect.width / aspect;

                if (finalH > rect.height) {
                    finalH = rect.height;
                    finalW = finalH * aspect;
                }

                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = LOGICAL_WIDTH * dpr;
                this.canvas.height = LOGICAL_HEIGHT * dpr;
                this.canvas.style.width = `${finalW}px`;
                this.canvas.style.height = `${finalH}px`;
                this.ctx.scale(dpr, dpr);
            }

            init() {
                document.getElementById('loading').style.display = 'none';
                this.checkLogin();
                this.spawnEnemy();
                
                try {
                    this.refreshShop();
                    this.checkSynergies();
                } catch(e) {
                    console.error("Init error:", e);
                }
                
                this.renderLoop();
            }

            bindInput() {
                const startDrag = (x, y) => {
                    if (this.state !== 'PLANNING') return;
                    const rect = this.canvas.getBoundingClientRect();
                    const logicalX = (x - rect.left) * (LOGICAL_WIDTH / rect.width);
                    const logicalY = (y - rect.top) * (LOGICAL_HEIGHT / rect.height);

                    // ËÆ∞ÂΩïÊãñÊãΩÂâçÁöÑÂéüÂßã‰ΩçÁΩÆÔºåÁî®‰∫éÂõûÂºπ
                    for (let u of this.units) {
                        if (u.team === 0 && Math.hypot(logicalX - u.pixelX, logicalY - u.pixelY) < TILE_SIZE/2) {
                            this.dragging = u;
                            u.oldR = u.r; 
                            u.oldC = u.c;
                            u.isDragging = true;
                            u.scale = 1.2;
                            return;
                        }
                    }
                };

                const moveDrag = (x, y) => {
                    if (!this.dragging) return;
                    const rect = this.canvas.getBoundingClientRect();
                    this.dragging.pixelX = (x - rect.left) * (LOGICAL_WIDTH / rect.width);
                    this.dragging.pixelY = (y - rect.top) * (LOGICAL_HEIGHT / rect.height);
                };

                const endDrag = () => {
                    if (!this.dragging) return;
                    const u = this.dragging;
                    u.isDragging = false;
                    u.scale = 1;
                    
                    // ËÆ°ÁÆóÁõÆÊ†áÁΩëÊ†º
                    const boardW = GRID_W * TILE_SIZE;
                    const boardH = GRID_H * TILE_SIZE;
                    const startX = (LOGICAL_WIDTH - boardW) / 2;
                    const startY = (LOGICAL_HEIGHT - boardH) / 2;
                    
                    let c = Math.floor((u.pixelX - startX) / TILE_SIZE);
                    let r = Math.floor((u.pixelY - startY) / TILE_SIZE);

                    // ËæπÁïåÊ£ÄÊü•
                    if (c < 0) c = 0; if (c >= GRID_W) c = GRID_W - 1;
                    if (r < 3) r = 3; if (r >= GRID_H) r = GRID_H - 1; // Âè™ËÉΩÊîæÂú®‰∏ãÂçäÂå∫

                    // --- Á¢∞ÊíûÊ£ÄÊµã‰∏é‰ΩçÁΩÆ‰∫§Êç¢ ---
                    const targetUnit = this.units.find(other => other !== u && other.team === 0 && other.c === c && other.r === r);
                    
                    if (targetUnit) {
                        // ÁõÆÊ†áÊ†ºÂ≠êÊúâ‰∫∫ -> ‰∫§Êç¢‰ΩçÁΩÆ
                        targetUnit.c = u.oldC;
                        targetUnit.r = u.oldR;
                        targetUnit.targetX = targetUnit.getGridX(targetUnit.c);
                        targetUnit.targetY = targetUnit.getGridY(targetUnit.r);
                        targetUnit.pixelX = targetUnit.targetX; // Áû¨ÁßªÂõûÂéªÊàñËÆ©updateÂπ≥ÊªëÂ§ÑÁêÜ
                        targetUnit.pixelY = targetUnit.targetY;
                        
                        u.c = c; u.r = r;
                    } else {
                        // Ê≤°‰∫∫ -> Ê≠£Â∏∏ÊîæÁΩÆ
                        u.c = c; u.r = r;
                    }

                    u.snap(); // ËÆ°ÁÆóÊñ∞ÁöÑ targetX/Y
                    this.dragging = null;
                    this.checkSynergies();
                };

                this.canvas.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
                window.addEventListener('mousemove', e => moveDrag(e.clientX, e.clientY));
                window.addEventListener('mouseup', endDrag);
                this.canvas.addEventListener('touchstart', e => { e.preventDefault(); startDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
                window.addEventListener('touchmove', e => { if(this.dragging) e.preventDefault(); moveDrag(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
                window.addEventListener('touchend', endDrag);
            }

            renderLoop() {
                const now = performance.now();
                const dt = Math.min((now - (this.lastTime || now)) / 1000, 0.1);
                this.lastTime = now;

                this.update(dt);
                this.draw();
                requestAnimationFrame(() => this.renderLoop());
            }

            update(dt) {
                // --- FIX: Pass state to unit update ---
                this.units.forEach(u => u.update(dt, this.state));
                
                if (this.state === 'FIGHTING') {
                    this.combatLogic(dt);
                }
                document.getElementById('ui-hp').innerText = Math.floor(this.hp);
                document.getElementById('ui-gold').innerText = this.gold;
                document.getElementById('ui-round').innerText = this.round;
            }

combatLogic(dt) {
                const allies = this.units.filter(u => u.team===0 && !u.isDead);
                const enemies = this.units.filter(u => u.team===1 && !u.isDead);
                
                if (allies.length === 0 || enemies.length === 0) {
                    this.endRound(allies.length > 0);
                    return;
                }

                this.units.forEach(u => {
                    if (u.isDead) return;
                    let targets = u.team===0 ? enemies : allies;
                    let target = null;
                    let minD = Infinity;
                    
                    targets.forEach(t => {
                        let d = Math.hypot(t.pixelX - u.pixelX, t.pixelY - u.pixelY);
                        if (d < minD) { minD = d; target = t; }
                    });

                    if (!target) return;

                    const rangePx = u.range * TILE_SIZE;
                    
                    // ÊîªÂáªÂà§ÂÆö
                    if (minD <= rangePx) {
                        if (performance.now()/1000 - u.lastAtk > (1/u.as)) {
                            u.lastAtk = performance.now()/1000;
                            const isCrit = Math.random() < 0.1; 
                            const dmg = Math.floor(u.dmg * (isCrit?1.5:1));
                            target.hp -= dmg;
                            u.mana += 10;
                            this.spawnText(target.pixelX, target.pixelY, dmg, isCrit);
                            if (target.hp <= 0) { target.hp = 0; target.isDead = true; }
                        }
                    } else {
                        // --- ÁßªÂä®ÈÄªËæë (Âê´Èò≤ÈáçÂè†) ---
                        const angle = Math.atan2(target.pixelY - u.pixelY, target.pixelX - u.pixelX);
                        let vx = Math.cos(angle) * 60; 
                        let vy = Math.sin(angle) * 60;

                        // ÊñΩÂä†Êñ•Âäõ (Separation Force)
                        this.units.forEach(other => {
                            if (u === other || other.isDead) return;
                            const dx = u.pixelX - other.pixelX;
                            const dy = u.pixelY - other.pixelY;
                            const dist = Math.hypot(dx, dy);
                            const safeRadius = 55; // ËßíËâ≤Á¢∞Êíû‰ΩìÁßØÂçäÂæÑ

                            if (dist < safeRadius && dist > 0) {
                                const force = (safeRadius - dist) / safeRadius; // Ë∑ùÁ¶ªË∂äËøëÊñ•ÂäõË∂äÂ§ß
                                const pushStrength = 300; // Êñ•ÂäõÂº∫Â∫¶
                                vx += (dx / dist) * force * pushStrength;
                                vy += (dy / dist) * force * pushStrength;
                            }
                        });

                        u.pixelX += vx * dt; 
                        u.pixelY += vy * dt;
                    }
                });
            }

            spawnText(x, y, txt, crit) {
                const canvasRect = this.canvas.getBoundingClientRect();
                const screenX = (x / LOGICAL_WIDTH) * canvasRect.width; 
                const screenY = (y / LOGICAL_HEIGHT) * canvasRect.height;

                const el = document.createElement('div');
                el.className = 'float-text';
                el.innerText = txt;
                el.style.color = crit ? '#ffcc00' : '#fff';
                el.style.fontSize = crit ? '28px' : '18px';
                
                document.getElementById('canvas-wrapper').appendChild(el);
                el.style.left = (screenX + canvasRect.width*0.05) + 'px'; 
                el.style.top = (screenY) + 'px';
                setTimeout(() => el.remove(), 600);
            }

            draw() {
                this.ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
                
                // 1. Board
                const boardW = GRID_W * TILE_SIZE;
                const boardH = GRID_H * TILE_SIZE;
                const startX = (LOGICAL_WIDTH - boardW) / 2;
                const startY = (LOGICAL_HEIGHT - boardH) / 2;

                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.roundRect(startX - 10, startY - 10, boardW + 20, boardH + 20, 15);
                this.ctx.fill();
                
                this.ctx.strokeStyle = 'rgba(255,255,255,0.05)';
                this.ctx.lineWidth = 2;

                for (let r=0; r<GRID_H; r++) {
                    for (let c=0; c<GRID_W; c++) {
                        const x = startX + c*TILE_SIZE;
                        const y = startY + r*TILE_SIZE;
                        
                        if ((r+c)%2===0) this.ctx.fillStyle = 'rgba(255,255,255,0.02)';
                        else this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
                        
                        this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                        this.ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                    }
                }

                // Divider
                const midY = startY + 3 * TILE_SIZE;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, midY);
                this.ctx.lineTo(startX + boardW, midY);
                this.ctx.strokeStyle = 'rgba(255, 71, 87, 0.4)';
                this.ctx.lineWidth = 4;
                this.ctx.setLineDash([10, 10]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 2. Units
                const sorted = [...this.units].sort((a,b) => a.pixelY - b.pixelY);
                sorted.forEach(u => u.draw(this.ctx));
                
                // 3. Drag Hint
                if (this.dragging) {
                    const dx = this.dragging.pixelX;
                    const dy = this.dragging.pixelY;
                    let c = Math.floor((dx - startX) / TILE_SIZE);
                    let r = Math.floor((dy - startY) / TILE_SIZE);
                    if (c >= 0 && c < GRID_W && r >= 3 && r < GRID_H) {
                        this.ctx.fillStyle = 'rgba(10, 132, 255, 0.3)';
                        this.ctx.fillRect(startX + c*TILE_SIZE, startY + r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            spawnEnemy() {
                const count = 2 + Math.floor(this.round * 0.5);
                const keys = Object.keys(UNIT_STATS);
                for(let i=0; i<count; i++) {
                    const k = keys[Math.floor(Math.random()*keys.length)];
                    const r = Math.floor(Math.random()*3);
                    const c = Math.floor(Math.random()*GRID_W);
                    if(!this.units.find(u=>u.team===1 && u.r===r && u.c===c)) {
                        const u = new Unit(k, 1, r, c);
                        this.units.push(u);
                    }
                }
            }

            refreshShop(cost = false) {
                if (cost) {
                    if (this.gold < 2) return;
                    this.gold -= 2;
                }
                const container = document.getElementById('shop-container');
                container.innerHTML = '';
                
                const keys = Object.keys(UNIT_STATS);
                for(let i=0; i<5; i++) {
                    const k = keys[Math.floor(Math.random()*keys.length)];
                    const data = UNIT_STATS[k];
                    
                    const unitName = LANG[this.lang].units[k].name;
                    const originName = LANG[this.lang].synergies[data.origin].name;
                    const className = LANG[this.lang].synergies[data.class].name;

                    const el = document.createElement('div');
                    el.className = 'card';
                    el.dataset.cost = data.cost;
                    el.innerHTML = `
                        <div class="c-cost">üíé${data.cost}</div>
                        <div class="card-img-box"><img src="${ASSET_SOURCES[k]}"></div>
                        <div class="card-info">
                            <div class="c-name">${unitName}</div>
                            <div class="c-meta">${originName} / ${className}</div>
                        </div>
                    `;
                    el.onclick = () => this.buyUnit(k);
                    container.appendChild(el);
                }
            }

            buyUnit(type) {
                if (this.state !== 'PLANNING') return;
                const cost = UNIT_STATS[type].cost;
                if (this.gold >= cost) {
                    for(let r=3; r<GRID_H; r++) {
                        for(let c=0; c<GRID_W; c++) {
                            if(!this.units.find(u=>u.team===0 && u.r===r && u.c===c)) {
                                this.gold -= cost;
                                const u = new Unit(type, 0, r, c);
                                this.units.push(u);
                                this.checkSynergies();
                                return;
                            }
                        }
                    }
                    alert(LANG[this.lang].emptyBench);
                }
            }

            checkSynergies() {
                const team = this.units.filter(u => u.team === 0);
                const counts = {};
                team.forEach(u => {
                    const d = UNIT_STATS[u.type];
                    counts[d.origin] = (counts[d.origin]||0) + 1;
                    counts[d.class] = (counts[d.class]||0) + 1;
                });

                const panel = document.getElementById('synergy-float');
                panel.innerHTML = '';
                
                for (let k in counts) {
                    const rule = SYN_RULES[k];
                    if (!rule) continue;
                    const active = counts[k] >= rule.req;
                    
                    const div = document.createElement('div');
                    div.className = `syn-tag ${active?'active':''}`;
                    const loc = LANG[this.lang].synergies[k];
                    div.innerHTML = `
                        <div class="syn-head"><span>${loc.name}</span> <span>${counts[k]}/${rule.req}</span></div>
                        ${active ? `<div class="syn-body">${loc.desc}</div>` : ''}
                    `;
                    panel.appendChild(div);
                }
            }

            toggleState() {
                if (this.state === 'PLANNING') {
                    this.state = 'FIGHTING';
                    document.getElementById('shop-dock').classList.remove('visible');
                    document.getElementById('txt-battle').innerText = LANG[this.lang].battleFighting;
                    document.getElementById('btn-battle').style.filter = "grayscale(1)";
                }
            }

            endRound(win) {
                this.state = 'PLANNING';
                document.getElementById('shop-dock').classList.add('visible');
                
                if (!win) this.hp -= 10;
                if (this.hp <= 0) {
                    alert(LANG[this.lang].gameOver);
                    location.reload();
                }
                
                this.round++;
                this.gold += 5;
                
                this.units = this.units.filter(u => u.team===0);
                this.units.forEach(u => {
                    u.hp = u.maxHp; u.mana = 0; u.isDead = false;
                    u.snap(); // Reset pos
                });
                
                this.spawnEnemy();
                this.refreshShop(true); 
                document.getElementById('txt-battle').innerText = LANG[this.lang].battleStart;
                document.getElementById('btn-battle').style.filter = "none";
                
                this.spawnText(LOGICAL_WIDTH/2, LOGICAL_HEIGHT/2, win ? LANG[this.lang].victory : LANG[this.lang].defeat, win);
            }

            toggleLang() {
                this.lang = this.lang === 'en' ? 'zh' : 'en';
                this.updateUI();
                this.refreshShop(); 
                this.checkSynergies();
            }
            
            updateUI() {
                const L = LANG[this.lang];
                document.getElementById('txt-reroll').innerText = L.reroll;
                document.getElementById('txt-battle').innerText = this.state==='PLANNING'? L.battleStart : L.battleFighting;
                document.getElementById('t-login-title').innerText = L.loginTitle;
                document.getElementById('t-login-desc').innerText = L.loginDesc;
                document.getElementById('t-rank-title').innerText = L.rankTitle;
            }

            checkLogin() {
                if(!localStorage.getItem('u_name')) {
                    document.getElementById('login-modal').style.display = 'flex';
                } else {
                    this.start();
                }
            }
            login() {
                const n = document.getElementById('username-input').value || "Commander";
                localStorage.setItem('u_name', n);
                document.getElementById('login-modal').style.display = 'none';
                this.start();
            }
            start() {
                this.updateUI();
                setTimeout(() => document.getElementById('shop-dock').classList.add('visible'), 500);
            }
            showRankings() {
                document.getElementById('rank-modal').style.display = 'flex';
                document.getElementById('rank-list-content').innerHTML = `<div style="padding:10px;">1. ${localStorage.getItem('u_name') || 'You'} - Round ${this.round}</div>`;
            }
        }

        const game = new Game();
        loadAssets(() => game.init());

    </script>
</body>
</html>